<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Breadth First Search | RedBlackTech</title><meta name=keywords content="academy,youtube,algorithms"><meta name=description content="The Algorithm Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as G={V,E}, where V is a set of vertices and E is a set of edges.
In more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post)."><meta name=author content><link rel=canonical href=https://redblacktech.com/staging/posts/bft/><link crossorigin=anonymous href=/staging/assets/css/stylesheet.7889c5527cadd77e68307af468fcf280ab1830eaa61b1978ce2d81a38a1bb7e6.css integrity="sha256-eInFUnyt135oMHr0aPzygKsYMOqmGxl4zi2Bo4obt+Y=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/staging/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://redblacktech.com/staging/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://redblacktech.com/staging/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://redblacktech.com/staging/favicon-32x32.png><link rel=apple-touch-icon href=https://redblacktech.com/staging/apple-touch-icon.png><link rel=mask-icon href=https://redblacktech.com/staging/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-K5SG3J1MFN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K5SG3J1MFN")</script><script src=/staging/js/cards.js></script><meta property="og:title" content="Breadth First Search"><meta property="og:description" content="The Algorithm Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as G={V,E}, where V is a set of vertices and E is a set of edges.
In more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post)."><meta property="og:type" content="article"><meta property="og:url" content="https://redblacktech.com/staging/posts/bft/"><meta property="og:image" content="https://redblacktech.com/staging/levels.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-23T18:13:11-05:00"><meta property="article:modified_time" content="2022-12-23T18:13:11-05:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://redblacktech.com/staging/levels.png"><meta name=twitter:title content="Breadth First Search"><meta name=twitter:description content="The Algorithm Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as G={V,E}, where V is a set of vertices and E is a set of edges.
In more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://redblacktech.com/staging/posts/"},{"@type":"ListItem","position":3,"name":"Breadth First Search","item":"https://redblacktech.com/staging/posts/bft/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Breadth First Search","name":"Breadth First Search","description":"The Algorithm Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as G={V,E}, where V is a set of vertices and E is a set of edges.\nIn more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post).","keywords":["academy","youtube","algorithms"],"articleBody":"The Algorithm Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as G={V,E}, where V is a set of vertices and E is a set of edges.\nIn more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post).\nThe algorithm also doubles down as a single source shortest path (SSSP) algorithm on unweighted graphs.\nBelow is the pseudo-code for breadth first search. I’ve coded it so that you can -instead of modify the funciton to make it do what you want- fill in the callback function named on_visit.\ninput: adjacency list output: shortest path tree function bft(G, on_visit): q = [0] while q not empty: node = q.popLeft() on_visit(node) mark current as visted for neighbor in G[node]: if neighbor not visted: q.addRight(neighbor) Key Points:\nlevel-order traversal implicitly traveses shortest path tree on an unweighted graph can pass in a callback to execute upon visiting a node Analysis Runtime for an Adjacency List The runtime of breadth first traversal depends on the type of graph provided as input. In the snippet above I’ve implied that the graph is an adjacency list. Why? If you look at the for loop, you’ll notice that G[node] is a collection of neighbors of node.\nG = [ [...], [...], [...] ] So in an adjacency list, if we wanna find all neighbors of a vertex v, we get access to the neighbor collection in constant time (O(1)), which again we access through G[v]. That said, the following is the algorithm runtime:\nvisting all vertices: O(V) visiting all neighbors of all vertices: O(E); for each vertex v this costs O(#neighbors(v)), which by definition sums to O(E) total: O(V) + O(E) = O(V+E) Runtime for an Adjacency Matrix The alternative to an adjacency list is an adjacency matrix. Think the Pokémon type chart, where if two vertices (types in this case) are related, the cell they intersect at captures the relationship. Below is a simplified version of the type advantage chart.\nG[row_type][column_type] == 1 means the row type beats the column type.\nG = [ #FIRE WATER, GRASS [0, 0, 1], #FIRE [1, 0, 0], #WATER [0, 1, 0] #GRASS ] If we wanna find all the vertices related to a given v in an adjacency matrix, we can’t just use G[v]. We need to also filter by the edges that equal 1, which costs O(V) per vertex we visit. Given all this, below is the analysis:\nvisting all vertices: O(V) cost per visit: O(V); again must filter through all vertices to find neighbors total: O(V^2) TL;DR The bottleneck for the runtime of breadth first traversal is the neighbor-finding part of the algorithm. In an adjacency list that step costs O(1), and in an adjacency matrix that step costs O(V).\nRuntimes:\nBFT on adjacency list: O(V + E) BFT on adjacency matrix: O(V^2) The way I learned algorithms [Ad] Note Please excuse the wordiness of this post - I lost the drawings that I would’ve used for this post, so I decided to keep it wordy and post my relevant YouTube short here, as well as the code and the key points.\nSubscribe to the channel if you haven’t already!\n","wordCount":"581","inLanguage":"en","image":"https://redblacktech.com/staging/levels.png","datePublished":"2022-12-23T18:13:11-05:00","dateModified":"2022-12-23T18:13:11-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://redblacktech.com/staging/posts/bft/"},"publisher":{"@type":"Organization","name":"RedBlackTech","logo":{"@type":"ImageObject","url":"https://redblacktech.com/staging/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://redblacktech.com/staging accesskey=h title="RedBlackTech (Alt + H)">RedBlackTech</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://redblacktech.com/staging/contactus title="About Us"><span>About Us</span></a></li><li><a href=https://redblacktech.com/staging/posts title=Academy><span>Academy</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Breadth First Search</h1><div class=post-meta><span title='2022-12-23 18:13:11 -0500 -0500'>December 23, 2022</span>&nbsp;·&nbsp;3 min</div></header><figure class=entry-cover><img loading=lazy src=https://redblacktech.com/staging/posts/bft/levels.png alt></figure><div class=post-content><h1 id=the-algorithm>The Algorithm<a hidden class=anchor aria-hidden=true href=#the-algorithm>#</a></h1><p>Breadth first traversal (usually interchanged with breadth first search), is a graph traversal algorithm that works in a level order manner. Our graph is defined as <code>G={V,E}</code>, where <code>V</code> is a set of vertices and <code>E</code> is a set of edges.</p><p>In more intuitive words: you start from some point on a graph and expand outward one level at a time. The first level is simply one node, and the next levels are simply all the nodes near a node in the previous level (see the colorful graph on the cover of this post).</p><p>The algorithm also doubles down as a single source shortest path (SSSP) algorithm on unweighted graphs.</p><p>Below is the pseudo-code for breadth first search. I&rsquo;ve coded it so that you can -instead of modify the funciton to make it do what you want- fill in the callback function named <code>on_visit</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-basic data-lang=basic><span style=display:flex><span>input: adjacency list
</span></span><span style=display:flex><span>output: shortest path tree
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function bft(G, on_visit)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while q not empty:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        node <span style=color:#f92672>=</span> q<span style=color:#f92672>.</span>popLeft()
</span></span><span style=display:flex><span>        on_visit(node)
</span></span><span style=display:flex><span>        mark current as visted
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        for neighbor in G[node]<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            if neighbor not visted:
</span></span><span style=display:flex><span>                q<span style=color:#f92672>.</span>addRight(neighbor)
</span></span></code></pre></div><blockquote><p>Key Points:</p><ul><li>level-order traversal</li><li>implicitly traveses shortest path tree on an unweighted graph</li><li>can pass in a callback to execute upon visiting a node</li></ul></blockquote><h1 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h1><h2 id=runtime-for-an-adjacency-list>Runtime for an Adjacency List<a hidden class=anchor aria-hidden=true href=#runtime-for-an-adjacency-list>#</a></h2><p>The runtime of breadth first traversal depends on the type of graph provided as input. In the snippet above I&rsquo;ve implied that the graph is an adjacency list. Why? If you look at the <code>for</code> loop, you&rsquo;ll notice that <code>G[node]</code> is a collection of neighbors of <code>node</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#a6e22e>G</span> <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    [...],
</span></span><span style=display:flex><span>    [...],
</span></span><span style=display:flex><span>    [...]
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>So in an adjacency list, if we wanna find all neighbors of a vertex <code>v</code>, we get access to the neighbor collection in constant time (<code>O(1)</code>), which again we access through <code>G[v]</code>.
That said, the following is the algorithm runtime:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-basic data-lang=basic><span style=display:flex><span>visting all vertices: O(V)
</span></span><span style=display:flex><span>visiting all neighbors of all vertices: O(E); for each vertex v this costs O(<span style=color:#960050;background-color:#1e0010>#</span>neighbors(v)), which by definition sums to O(E)
</span></span><span style=display:flex><span>total:
</span></span><span style=display:flex><span>    O(V) <span style=color:#f92672>+</span> O(E)
</span></span><span style=display:flex><span>    <span style=color:#f92672>=</span> O(V<span style=color:#f92672>+</span>E)
</span></span></code></pre></div><h2 id=runtime-for-an-adjacency-matrix>Runtime for an Adjacency Matrix<a hidden class=anchor aria-hidden=true href=#runtime-for-an-adjacency-matrix>#</a></h2><p>The alternative to an adjacency list is an adjacency matrix. Think the <a href=https://pokemondb.net/type>Pokémon type chart</a>, where if two vertices (types in this case) are related, the cell they intersect at captures the relationship. Below is a simplified version of the type advantage chart.</p><p><code>G[row_type][column_type] == 1</code> means the row type beats the column type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>G <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#75715e>#FIRE   WATER,  GRASS</span>
</span></span><span style=display:flex><span>    [<span style=color:#ae81ff>0</span>,     <span style=color:#ae81ff>0</span>,      <span style=color:#ae81ff>1</span>],   <span style=color:#75715e>#FIRE</span>
</span></span><span style=display:flex><span>    [<span style=color:#ae81ff>1</span>,     <span style=color:#ae81ff>0</span>,      <span style=color:#ae81ff>0</span>],   <span style=color:#75715e>#WATER</span>
</span></span><span style=display:flex><span>    [<span style=color:#ae81ff>0</span>,     <span style=color:#ae81ff>1</span>,      <span style=color:#ae81ff>0</span>]    <span style=color:#75715e>#GRASS</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>If we wanna find all the vertices related to a given <code>v</code> in an adjacency matrix, we can&rsquo;t just use <code>G[v]</code>. We need to also filter by the edges that equal 1, which costs <code>O(V)</code> per vertex we visit. Given all this, below is the analysis:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-basic data-lang=basic><span style=display:flex><span>visting all vertices: O(V)
</span></span><span style=display:flex><span>cost per visit: O(V); again must filter through all vertices to find neighbors
</span></span><span style=display:flex><span>total: O(V<span style=color:#f92672>^</span><span style=color:#ae81ff>2</span>)
</span></span></code></pre></div><h2 id=tldr>TL;DR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>The bottleneck for the runtime of breadth first traversal is the neighbor-finding part of the algorithm. In an adjacency list that step costs <code>O(1)</code>, and in an adjacency matrix that step costs <code>O(V)</code>.</p><blockquote><p>Runtimes:</p><ul><li>BFT on adjacency list: <code>O(V + E)</code></li><li>BFT on adjacency matrix: <code>O(V^2)</code></li></ul></blockquote><a href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844?crid=2XH0U6T926TXG&keywords=clrs&qid=1672678328&sprefix=clrs%2Caps%2C91&sr=8-1&linkCode=li2&tag=redblacktech-20&linkId=d116d342e0a689da2a11dc9c10418f76&language=en_US&ref_=as_li_ss_il" target=_blank><div style=display:flex;flex-direction:column;align-items:center;background-color:rgba(128,128,128,5%);border-radius:10px;padding:100px;padding-top:20px;padding-bottom:20px><i>The way I learned algorithms [Ad]</i><div class=basic-ad><img border=0 alt="Ad Blocked" src="//ws-na.amazon-adsystem.com/widgets/q?_encoding=UTF8&ASIN=0262033844&Format=_SL160_&ID=AsinImage&MarketPlace=US&ServiceVersion=20070822&WS=1&tag=redblacktech-20&language=en_US">
<img src="https://ir-na.amazon-adsystem.com/e/ir?t=redblacktech-20&language=en_US&l=li2&o=1&a=0262033844" alt="Ad Blocked" width=1 height=1 border=0 alt style=border:none!important;margin:0!important></div></div></a><h1 id=note>Note<a hidden class=anchor aria-hidden=true href=#note>#</a></h1><p>Please excuse the wordiness of this post - I lost the drawings that I would&rsquo;ve used for this post, so I decided to keep it wordy and post my relevant YouTube short here, as well as the code and the key points.</p><div style=display:flex;flex-direction:column;align-items:center;margin-bottom:50px><div id=player></div><script>var tag=document.createElement("script"),firstScriptTag,player;tag.src="https://www.youtube.com/iframe_api",firstScriptTag=document.getElementsByTagName("script")[0],firstScriptTag.parentNode.insertBefore(tag,firstScriptTag);function onYouTubeIframeAPIReady(){player=new YT.Player("player",{width:"344",height:"614",videoId:"zNhIUO07Qhg",playerVars:{playsinline:1}})}</script></div><p>Subscribe to the channel if you haven&rsquo;t already!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://redblacktech.com/staging/tags/academy/>academy</a></li><li><a href=https://redblacktech.com/staging/tags/youtube/>youtube</a></li><li><a href=https://redblacktech.com/staging/tags/algorithms/>algorithms</a></li></ul><p style=margin-top:30px>Reading and thinking is the best way to master a topic. Find books <a target=_blank href="https://www.amazon.com/gp/search?ie=UTF8&tag=redblacktech-20&linkCode=ur2&linkId=0428dc36aa3e25cd6739634cb7e02a9a&camp=1789&creative=9325&index=pc-hardware&keywords=computer science textbook" style=text-decoration-line:underline>here</a> 📚. The next best thing is our <a target=_blank href=https://youtube.com/@_rbt style=text-decoration-line:underline>channel</a> 📺.</p></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://redblacktech.com/staging>RedBlackTech</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>